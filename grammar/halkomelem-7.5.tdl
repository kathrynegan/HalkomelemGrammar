;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Grammar of Halkomelem
;;; created at:
;;;     Fri May 17 04:36:49 UTC 2013
;;; based on Matrix customization system version of:
;;;     Fri Apr 26 22:56:20 UTC 2013
;;;
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Type assigning empty mod list. Added to basic types for nouns, verbs and determiners.

non-mod-lex-item := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ].

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;

+np :+ [ CASE case,
    CASE-MARKED bool ].

head :+ [ FORM form,
    AUX bool ].

inflected :+ [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG luk,
    NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG luk,
    MAIN-CLAUSE-AUX-FLAG luk,
    FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG luk,
    TRANS-SUFFIX-FLAG luk,
    ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG luk,
    MC-AUX-SUBJ-FLAG luk,
    SUBJ-SUFFIX-FLAG luk,
    OBJ-SUFFIX-FLAG luk ].

infl-satisfied :+ [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG na-or-+,
    NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG na-or-+,
    MAIN-CLAUSE-AUX-FLAG na-or-+,
    FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG na-or-+,
    TRANS-SUFFIX-FLAG na-or-+,
    ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG na-or-+,
    MC-AUX-SUBJ-FLAG na-or-+,
    SUBJ-SUFFIX-FLAG na-or-+,
    OBJ-SUFFIX-FLAG na-or-+ ].

png :+ [ PER person,
    NUM number,
    GEND gender,
    PROXIMITY proximity ].

basic-head-comp-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc,
    SYNSEM.LOCAL.CAT [ MC #mc,
                       VC #vc ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VC #vc ].

basic-head-mod-phrase-simple :+ [ SYNSEM.LOCAL.CAT.MC #mc,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

; Introducing VC keeps track whether main-verb is present in cluster

cat :+ [ VC luk,
         INIT luk ].

lex-rule :+ [ SYNSEM.LOCAL.CAT.VC #vc,
    DTR.SYNSEM.LOCAL.CAT.VC #vc ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Case

case := *top*.
cor := case.  ; core
obl := case.  ; oblique

;;; Person

person := *top*.
3rd := person.
non-3rd := person.
2nd := non-3rd.
1st := non-3rd.

;;; Number

number := *top*.
sg := number.
pl := number.

;;; Gender

gender := *top*.
feminine := gender.
masculine := gender.

;;; Proximity

proximity := *top*.
visible := proximity.
near-invisible := proximity.
remote := proximity.

;;; Form

form := *top*.
nonfinite := form.
finite := form.
subord := nonfinite.
nonfin := nonfinite.
nom := nonfinite.

;;; Tense

past := tense.
present := tense.
future := tense.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

;;; Nouns

noun-lex := basic-noun-lex & basic-one-arg & no-hcons-lex-item & non-mod-lex-item &
  [ ARG-ST < #spr >,
    SYNSEM.LOCAL.CAT.VAL [ COMPS < >,
                           SUBJ < >,
                           SPEC < >,
                           SPR < #spr &
                                 [ LOCAL.CAT.HEAD det,
                                   OPT - ] > ] ].

masc-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEND masculine ].

fem-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.GEND feminine ].

basic-noun-noun-lex := noun-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

fem-basic-noun-lex := fem-noun-lex & basic-noun-noun-lex.

masc-basic-noun-lex := masc-noun-lex & basic-noun-noun-lex.

;;; Verbs

verb-lex := non-mod-lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD verb,
                       HC-LIGHT - ] ].

main-verb-lex := verb-lex & basic-verb-lex &
  [ SYNSEM.LOCAL [ CAT [ INIT +,
                         HEAD.AUX -,
                         VC +,
                         VAL [ SPR < >,
                               SPEC < >,
                               SUBJ < #subj > ] ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT.VAL [ SPR < >,
                                     COMPS < > ],
                           CONT.HOOK.INDEX #xarg ] ] ].

aux-lex := verb-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.AUX +,
                       VC - ] ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST.FIRST.LOCAL.CAT.HEAD +np ].

transitive-verb-lex := main-verb-lex & transitive-lex-item & durative-prefix-rule-dtr & emph-prefix-rule-dtr & intrans-suffix-rule-dtr & nom-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD +np ],
             #comps &
             [ LOCAL.CAT [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD +np ] ] > ].

cor-intransitive-verb-lex := intransitive-verb-lex &
  [ ARG-ST.FIRST.LOCAL.CAT.HEAD noun &
                                [ CASE cor ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CAT.HEAD.CASE-MARKED + ] > ].

cor-obl-transitive-verb-lex := transitive-verb-lex &
  [ ARG-ST < [ LOCAL.CAT.HEAD noun &
                              [ CASE cor ] ],
             [ LOCAL.CAT.HEAD adp &
                              [ CASE obl ] ] >,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CAT.HEAD.CASE-MARKED + ] >,
                           COMPS < [ LOCAL.CAT.HEAD.CASE-MARKED + ] > ] ].

trans-obl-verb-lex := cor-obl-transitive-verb-lex &
  [ INFLECTED.NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG - ].

trans-verb-lex := transitive-verb-lex & obj-suffix-rule-dtr & trans-agr-suffix-rule-dtr &
  [ INFLECTED [ NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG -,
                TRANS-SUFFIX-FLAG - ] ].

;;; Auxiliaries

arg-comp-aux := aux-lex & basic-two-arg &
  [ SYNSEM.LOCAL [ CAT.VAL [ SPR < >,
                             SPEC < >,
                             COMPS < #comps . #vcomps >,
                             SUBJ < #subj > ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT [ HEAD noun &
                                  [ CASE #case ],
                             VAL [ SUBJ < >,
                                   SPR < >,
                                   SPEC < >,
                                   COMPS < > ] ],
                       CONT.HOOK.INDEX #xarg ] ],
             #comps &
             [ LIGHT +,
               LOCAL [ CONT.HOOK.XARG #xarg,
                       CAT [ HEAD verb,
                             VAL [ COMPS #vcomps,
                                   SUBJ < [ LOCAL.CAT.HEAD.CASE #case ] > ] ] ] ] > ].

; Somewhat surprisingly, this inherits from basic-two-arg, so
; that the non-local features are amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Note that raise-sem-lex-item assumes the first complement is
; where the HOOK comes from.  It's not clear to me how you'd
; tell that you had an argument composition auxiliary if it
; wasn't appearing adjacent to the verb.

; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.

arg-comp-aux-no-pred := arg-comp-aux & raise-sem-lex-item &
  [ ARG-ST < [ ],
             [ ] > ].

main-clause-aux-lex := arg-comp-aux-no-pred & durative-prefix-rule-dtr & emph-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM nonfin,
    INFLECTED [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG +,
                MAIN-CLAUSE-AUX-FLAG +,
                ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG +,
                MC-AUX-SUBJ-FLAG -,
                FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG + ] ].

; Somewhat surprisingly, this inherits from basic-two-arg, so
; that the non-local features are amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

arg-comp-aux-with-pred := arg-comp-aux & hcons-lex-item &
  [ SYNSEM [ LOCAL.CONT.HCONS <! qeq &
                                 [ HARG #harg,
                                   LARG #larg ] !>,
             LKEYS.KEYREL event-relation &
                          [ ARG1 #harg ] ],
    ARG-ST < [ ],
             [ LOCAL.CONT.HOOK.LTOP #larg ] > ].

full-aux-lex := arg-comp-aux-with-pred & durative-prefix-rule-dtr & emph-prefix-rule-dtr & nom-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM nonfin,
                       INIT + ],
    INFLECTED [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG +,
                NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG -,
                FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG + ] ].

; Somewhat surprisingly, this inherits from basic-two-arg, so
; that the non-local features are amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

neg-aux-lex := arg-comp-aux-with-pred &
  [ SYNSEM.LOCAL.CAT [ HEAD.FORM finite,
                       VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM subord ] ].

; Somewhat surprisingly, this inherits from basic-two-arg, so
; that the non-local features are amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

adverbial-aux-lex := arg-comp-aux-with-pred & durative-prefix-rule-dtr & emph-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM nonfin,
                       INIT + ],
    INFLECTED [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG +,
                ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG +,
                SUBJ-SUFFIX-FLAG - ] ].

; Somewhat surprisingly, this inherits from basic-two-arg, so
; that the non-local features are amalgamated from subj, the
; lexical verb complement, but not the other complements, if any.

; Note that raise-sem-lex-item assumes the first complement is
; where the HOOK comes from.  It's not clear to me how you'd
; tell that you had an argument composition auxiliary if it
; wasn't appearing adjacent to the verb.

; To keep the semantically empty ones from spinning on
; generation, require complement to be [AUX -].  The
; FORM feature might be enough in the starter grammars,
; but I don't want to rely on this.  Then again, [ AUX - ]
; might not be true.

interrog-aux-lex := arg-comp-aux-no-pred &
  [ SYNSEM.LOCAL [ CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
                         INIT - ],
  		           CONT.HOOK.INDEX.SF ques ] ]. 
;;; Others

;;; Case-marking adpositions
;;; Case marking adpositions are constrained not to
;;; be modifiers.

case-marking-adp-lex := basic-one-arg & raise-sem-lex-item &
  [ SYNSEM.LOCAL.CAT [ HEAD adp &
                            [ CASE #case,
                              MOD < > ],
                       VAL [ SPR < >,
                             SUBJ < >,
                             COMPS < #comps >,
                             SPEC < > ] ],
    ARG-ST < #comps &
             [ LOCAL.CAT [ VAL.SPR < >,
                           HEAD noun &
                                [ CASE #case,
                                  CASE-MARKED - ] ] ] > ].

;;; Determiners

determiner-lex-supertype := norm-hook-lex-item & basic-zero-arg & non-mod-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD det &
 			        [ MOD < > ],
                           VAL[ SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,
                                                             LTOP #larg ],
                                SPR < >,
                                SUBJ < >,
                                COMPS < > ] ],
                     CONT [ HCONS < ! qeq &
                                    [ HARG #harg,
                                      LARG #larg ] ! >,
                            RELS < ! [ PRED "exist_q_rel" ],
                                       #altkey ! > ] ],
            LKEYS.ALTKEYREL #altkey & arg1-ev-relation &
                           [ LBL #larg,
                             ARG1 #ind ],
            LKEYS.KEYREL quant-relation &
                       [ ARG0 #ind,
                         RSTR #harg ] ] ].
		     
demonstrative-det-lex:= determiner-lex-supertype &
	[ SYNSEM.LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.COG-ST activ+fam ].
								
article-det-lex := determiner-lex-supertype.

m_p-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PROXIMITY visible,
    		 LKEYS.ALTKEYREL.PRED "proximal+dem_a_rel" ] ].
  
m_p-dem-lex := m_p-determiner-lex & demonstrative-det-lex.

m_p-art-lex := m_p-determiner-lex & article-det-lex.

f_p-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ GEND feminine,
                                                                PROXIMITY visible ] ,
    		 LKEYS.ALTKEYREL.PRED "proximal+dem_a_rel" ] ].
                                                                
f_p-dem-lex := f_p-determiner-lex & demonstrative-det-lex.

f_p-art-lex := f_p-determiner-lex & article-det-lex.

m_n-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PROXIMITY near-invisible ,
    		 LKEYS.ALTKEYREL.PRED "distal+dem_a_rel" ] ].
  
m_n-dem-lex := m_n-determiner-lex & demonstrative-det-lex.

m_n-art-lex := m_n-determiner-lex & article-det-lex.

f_n-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ GEND feminine,
                                                                PROXIMITY near-invisible ] ,
    		 LKEYS.ALTKEYREL.PRED "distal+dem_a_rel" ] ].
                                                                
f_n-dem-lex := f_n-determiner-lex & demonstrative-det-lex.

f_n-art-lex := f_n-determiner-lex & article-det-lex.

m_r-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PROXIMITY remote ,
    		 LKEYS.ALTKEYREL.PRED "remote+dem_a_rel" ] ].
  
m_r-dem-lex := m_r-determiner-lex & demonstrative-det-lex.

m_r-art-lex := m_r-determiner-lex & article-det-lex.

f_r-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ GEND feminine,
                                                                PROXIMITY remote ] ,
    		 LKEYS.ALTKEYREL.PRED "remote+dem_a_rel" ] ].
                                                                
f_r-dem-lex := f_r-determiner-lex & demonstrative-det-lex.

f_r-art-lex := f_r-determiner-lex & article-det-lex.

pl_p-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                PROXIMITY visible ] ,
    		 LKEYS.ALTKEYREL.PRED "proximal+dem_a_rel" ] ].
                                                                
pl_p-dem-lex := pl_p-determiner-lex & demonstrative-det-lex.

pl_p-art-lex := pl_p-determiner-lex & article-det-lex.

pl_n-determiner-lex := determiner-lex-supertype &
  [ SYNSEM [ LOCAL.CAT.VAL.SPEC.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                PROXIMITY near-invisible ] ,
    		 LKEYS.ALTKEYREL.PRED "distal+dem_a_rel" ] ].
                                                                
pl_n-dem-lex := pl_n-determiner-lex & demonstrative-det-lex.

pl_n-art-lex := pl_n-determiner-lex & article-det-lex.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

;;; Intermediate rule types

nom-prefix-rule-dtr := word-or-lexrule.
durative-prefix-rule-dtr := word-or-lexrule.
past-suffix-rule-dtr := word-or-lexrule.
trans-agr-suffix-rule-dtr := word-or-lexrule.
emph-prefix-rule-dtr := word-or-lexrule.
intrans-suffix-rule-dtr := word-or-lexrule.
obj-suffix-rule-dtr := word-or-lexrule.
still-prefix-rule-dtr := word-or-lexrule.
progressive-prefix-rule-dtr := word-or-lexrule.
subj-suffix-rule-dtr := word-or-lexrule.

;;; Lexical rule types

plural-prefix-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR basic-noun-noun-lex &
        [ INFLECTED #infl ] ].

plural-lex-rule := plural-prefix-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.PNG.NUM pl ].

trans-suffix-lex-rule-super := add-only-no-ccont-rule & durative-prefix-rule-dtr & emph-prefix-rule-dtr & nom-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ INFLECTED [ TRANS-SUFFIX-FLAG +,
                ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG #nom-subj-or-reg-subj-or-sub-subj,
                FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #full-aux-or-main-clause-aux,
                ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux,
                MAIN-CLAUSE-AUX-FLAG #main-clause-aux,
                MC-AUX-SUBJ-FLAG #mc-aux-subj,
                SUBJ-SUFFIX-FLAG #subj-suffix ],
    DTR trans-verb-lex &
        [ INFLECTED [ ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                      NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG #nom-subj-or-reg-subj-or-sub-subj,
                      FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #full-aux-or-main-clause-aux,
                      ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux,
                      MAIN-CLAUSE-AUX-FLAG #main-clause-aux,
                      MC-AUX-SUBJ-FLAG #mc-aux-subj,
                      SUBJ-SUFFIX-FLAG #subj-suffix ] ] ].

core-trans-lex-rule := infl-lex-rule & obj-suffix-rule-dtr & trans-agr-suffix-rule-dtr & trans-suffix-lex-rule-super &
  [ INFLECTED.OBJ-SUFFIX-FLAG -,
    SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST.LOCAL.CAT.HEAD [ CASE cor,
                                                       CASE-MARKED + ],
                           COMPS.FIRST.LOCAL.CAT.HEAD [ CASE cor,
                                                        CASE-MARKED + ] ] ].

obl-trans-lex-rule := const-lex-rule & intrans-suffix-rule-dtr & trans-suffix-lex-rule-super &
  [ INFLECTED.OBJ-SUFFIX-FLAG #obj-suffix,
    DTR.INFLECTED.OBJ-SUFFIX-FLAG #obj-suffix,
    SYNSEM.LOCAL.CAT.VAL [ COMPS.FIRST.LOCAL.CAT.HEAD [ CASE obl,
                                                        CASE-MARKED + ],
                           SUBJ.FIRST.LOCAL.CAT.HEAD [ CASE cor,
                                                       CASE-MARKED + ] ] ].

basic-core-trans-lex-rule := core-trans-lex-rule.

limit-core-trans-lex-rule := core-trans-lex-rule.

obj-suffix-lex-rule-super := add-only-no-ccont-rule & durative-prefix-rule-dtr & emph-prefix-rule-dtr & nom-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr & trans-agr-suffix-rule-dtr &
  [ INFLECTED [ OBJ-SUFFIX-FLAG +,
                ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG #nom-subj-or-reg-subj-or-sub-subj,
                FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #full-aux-or-main-clause-aux,
                ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux,
                TRANS-SUFFIX-FLAG #trans-suffix,
                MAIN-CLAUSE-AUX-FLAG #main-clause-aux,
                MC-AUX-SUBJ-FLAG #mc-aux-subj,
                SUBJ-SUFFIX-FLAG #subj-suffix ],
    DTR obj-suffix-rule-dtr &
        [ INFLECTED [ ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                      NOM-SUBJ-OR-REG-SUBJ-OR-SUB-SUBJ-FLAG #nom-subj-or-reg-subj-or-sub-subj,
                      FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #full-aux-or-main-clause-aux,
                      ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux,
                      TRANS-SUFFIX-FLAG #trans-suffix,
                      MAIN-CLAUSE-AUX-FLAG #main-clause-aux,
                      MC-AUX-SUBJ-FLAG #mc-aux-subj,
                      SUBJ-SUFFIX-FLAG #subj-suffix ] ] ].

1sg-obj-lex-rule := infl-lex-rule & obj-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                                                 PER 1st ] ].

2sg-obj-lex-rule := infl-lex-rule & obj-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                                                 PER 2nd ] ].

1pl-obj-lex-rule := infl-lex-rule & obj-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                 PER 1st ] ].

2pl-obj-lex-rule := infl-lex-rule & obj-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                 PER 2nd ] ].

3-obj-lex-rule := const-lex-rule & obj-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

trans-agr-suffix-lex-rule-super := add-only-no-ccont-rule & durative-prefix-rule-dtr & emph-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ INFLECTED #infl,
    DTR trans-agr-suffix-rule-dtr &
        [ INFLECTED #infl ] ].

non3-trans-agr-lex-rule := const-lex-rule & trans-agr-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER non-3rd ].

3-trans-agr-lex-rule := infl-lex-rule & trans-agr-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

intrans-suffix-lex-rule-super := add-only-no-ccont-rule & durative-prefix-rule-dtr & emph-prefix-rule-dtr & infl-lex-rule & nom-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr & subj-suffix-rule-dtr &
  [ INFLECTED #infl,
    DTR intrans-suffix-rule-dtr &
        [ INFLECTED [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux-or-neg-aux,
                      ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                      OBL-TRANS-FLAG #obl-trans,
                      TRANS-SUFFIX-FLAG #trans-suffix,
                      FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #full-aux-or-main-clause-aux-or-neg-aux,
                      ADVERBIAL-AUX-OR-FULL-AUX-OR-NEG-AUX-OR-OBL-TRANS-VERB-FLAG #adverbial-aux-or-full-aux-or-neg-aux-or-obl-trans-verb,
                      OBJ-SUFFIX-FLAG #obj-suffix,
                      TRANS-AGR-SUFFIX-FLAG #trans-agr-suffix,
                      SUBJ-SUFFIX-FLAG #subj-suffix,
                      MAIN-CLAUSE-AUX-FLAG #main-clause-aux ] ] ].

intrans-lex-rule := intrans-suffix-lex-rule-super.



subj-suffix-lex-rule-super := add-only-no-ccont-rule & durative-prefix-rule-dtr & emph-prefix-rule-dtr & past-suffix-rule-dtr & progressive-prefix-rule-dtr & still-prefix-rule-dtr &
  [ INFLECTED [ SUBJ-SUFFIX-FLAG +,
                ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux-or-neg-aux,
                FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #full-aux-or-main-clause-aux-or-neg-aux,
                OBL-TRANS-FLAG #obl-trans,
                INTRANS-SUFFIX-OR-TRANS-AGR-SUFFIX-FLAG #intrans-suffix-or-trans-agr-suffix,
                TRANS-SUFFIX-FLAG #trans-suffix,
                ADVERBIAL-AUX-OR-FULL-AUX-OR-NEG-AUX-OR-OBL-TRANS-VERB-FLAG #adverbial-aux-or-full-aux-or-neg-aux-or-obl-trans-verb,
                ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                OBJ-SUFFIX-FLAG #obj-suffix,
                TRANS-AGR-SUFFIX-FLAG #trans-agr-suffix,
                MAIN-CLAUSE-AUX-FLAG #main-clause-aux ],
    DTR subj-suffix-rule-dtr &
        [ INFLECTED [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux-or-neg-aux,
                      FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #full-aux-or-main-clause-aux-or-neg-aux,
                      OBL-TRANS-FLAG #obl-trans,
                      INTRANS-SUFFIX-OR-TRANS-AGR-SUFFIX-FLAG #intrans-suffix-or-trans-agr-suffix,
                      TRANS-SUFFIX-FLAG #trans-suffix,
                      ADVERBIAL-AUX-OR-FULL-AUX-OR-NEG-AUX-OR-OBL-TRANS-VERB-FLAG #adverbial-aux-or-full-aux-or-neg-aux-or-obl-trans-verb,
                      ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                      OBJ-SUFFIX-FLAG #obj-suffix,
                      TRANS-AGR-SUFFIX-FLAG #trans-agr-suffix,
                      MAIN-CLAUSE-AUX-FLAG #main-clause-aux ] ] ].

reg-subj-lex-rule := subj-suffix-lex-rule-super &
  [ DTR.INFLECTED.MAIN-CLAUSE-AUX-FLAG na ].

mc-aux-subj-lex-rule := infl-lex-rule & subj-suffix-lex-rule-super &
  [ DTR.INFLECTED [ TRANS-SUFFIX-FLAG na,
                    ADVERBIAL-AUX-OR-FULL-AUX-OR-NEG-AUX-OR-OBL-TRANS-VERB-FLAG na,
                    INTRANS-SUFFIX-OR-TRANS-AGR-SUFFIX-FLAG na ],
    SYNSEM.LOCAL.CAT.HEAD.FORM finite ].

1st-sg-subj-lex-rule := mc-aux-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                                                PER 1st ] ].

1st-pl-subj-lex-rule := mc-aux-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                PER 1st ] ].

2nd-sg-subj-lex-rule := mc-aux-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                                                PER 2nd ] ].

2nd-pl-subj-lex-rule := mc-aux-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                PER 2nd ] ].

3rd-subj-lex-rule := const-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD.FORM finite,
                       VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] ].

nonfin-subj-lex-rule := const-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM nonfin ].

1st-sg-sub-subj-lex-rule := infl-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD.FORM subord,
                       VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                                                  PER 1st ] ] ].

1st-pl-sub-subj-lex-rule := infl-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT [ VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                  PER 1st ],
                       HEAD.FORM subord ] ].

2nd-sg-sub-subj-lex-rule := infl-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT [ VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM sg,
                                                                  PER 2nd ],
                       HEAD.FORM subord ] ].

2nd-pl-sub-subj-lex-rule := infl-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT [ VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                  PER 2nd ],
                       HEAD.FORM subord ] ].

3rd-sub-subj-lex-rule := infl-lex-rule & reg-subj-lex-rule &
  [ SYNSEM.LOCAL.CAT [ VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd,
                       HEAD.FORM subord ] ].

past-suffix-lex-rule-super := add-only-no-ccont-rule & durative-prefix-rule-dtr & emph-prefix-rule-dtr & infl-lex-rule & progressive-prefix-rule-dtr & still-prefix-rule-dtr &
  [ INFLECTED #infl,
    DTR past-suffix-rule-dtr &
        [ INFLECTED #infl &
                    [ ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG na ] ] ].

past-tense-lex-rule := past-suffix-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE past ].

durative-prefix-lex-rule-super := add-only-no-ccont-rule & emph-prefix-rule-dtr & infl-lex-rule & progressive-prefix-rule-dtr & still-prefix-rule-dtr &
  [ INFLECTED #infl,
    DTR durative-prefix-rule-dtr &
        [ INFLECTED #infl &
                    [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG na ] ] ].

durative-aspect-lex-rule := durative-prefix-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT dur ].

progressive-prefix-lex-rule-super := add-only-no-ccont-rule & emph-prefix-rule-dtr & infl-lex-rule & still-prefix-rule-dtr &
  [ INFLECTED #infl,
    DTR progressive-prefix-rule-dtr &
        [ INFLECTED #infl &
                    [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG na ] ] ].

progressive-aspect-lex-rule := progressive-prefix-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT prog ].

still-prefix-lex-rule-super := add-only-no-ccont-rule & emph-prefix-rule-dtr & infl-lex-rule &
  [ INFLECTED #infl,
    DTR still-prefix-rule-dtr &
        [ INFLECTED #infl &
                    [ ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG na ] ] ].

still-aspect-lex-rule := still-prefix-lex-rule-super &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT still ].

emph-prefix-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED #infl,
    DTR emph-prefix-rule-dtr &
        [ INFLECTED #infl &
                    [ FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG na ] ] ].

emph-aspect-lex-rule := emph-prefix-lex-rule-super & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT emph ].

;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

;Constraint on MC used to be part of matrix.tdl
;;it applies to all wo implementations, except for v2

head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < > ].

head-subj-phrase := decl-head-subj-phrase & head-initial &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VC + ].

; Rules for building NPs.  Note that the Matrix uses SPR for
; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

head-spec-phrase := basic-head-spec-phrase & head-final.

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].

aux-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ SYNSEM.LOCAL.CAT [ HEAD verb &
                          [ AUX + ] ,
                       INIT + ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.INIT + ,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb,
                                    INIT na-or-+ ] ].

;;;;;;;;;;;;;;;;;;
;;; Coordination
;;;;;;;;;;;;;;;;;;

;;; Coordination Strategy 1

np1-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

np1-bottom-coord-rule := conj-first-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 1

vp1-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

vp1-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

vp1-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 1

s1-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

s1-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

s1-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].
  
   
 
 
 
 
 
 
 
 
 
  
;;;;;;;;;;;;;;;;
;;;;;;Added
;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;



basic-head-opt-subj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VC + ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Aspect

dur := aspect.
prog := aspect.
still := aspect.
emph := aspect.
still-dur := still & dur.
emph-dur := emph & dur.
prog-dur := prog & dur.
still-prog := still & prog.
emph-prog := emph & prog.
emph-still := emph & still.
emph-prog-dur := emph-prog & prog-dur & emph-dur.
still-prog-dur := still-prog & prog-dur & still-dur.
emph-still-dur := still-dur & emph-dur & emph-still.
emph-still-prog := still-prog & emph-prog & emph-still.
emph-still-prog-dur := emph-still-dur & emph-still-prog & emph-prog-dur & still-prog-dur.


;;; Predsort

demonstrative_a_rel := predsort.
proximal+dem_a_rel := demonstrative_a_rel.
distal+dem_a_rel := demonstrative_a_rel.
remote+dem_a_rel := distal+dem_a_rel.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

nominalizer-rule-dtr := word-or-lexrule.

nominalizer-lex-rule-super := add-only-no-ccont-rule & infl-lex-rule &
  [ INFLECTED [ NOM-PREFIX-FLAG +,
	        SUBJ-SUFFIX-FLAG #subj-suffix,
                ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #full-aux-or-main-clause-aux-or-neg-aux,
                OBJ-SUFFIX-FLAG #obj-suffix,
                INTRANS-SUFFIX-OR-TRANS-AGR-SUFFIX-FLAG #intrans-suffix-or-trans-agr-suffix,
                TRANS-AGR-SUFFIX-FLAG #trans-agr-suffix,
                ADVERBIAL-AUX-OR-FULL-AUX-OR-NEG-AUX-OR-OBL-TRANS-VERB-FLAG #adverbial-aux-or-full-aux-or-neg-aux-or-obl-trans-verb,
                MAIN-CLAUSE-AUX-FLAG #main-clause-aux,
                ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux-or-neg-aux,
                TRANS-SUFFIX-FLAG #trans-suffix,
                OBL-TRANS-FLAG #obl-trans ],
    DTR nominalizer-rule-dtr &
        [ INFLECTED [ SUBJ-SUFFIX-FLAG #subj-suffix,
                      ADVERBIAL-AUX-OR-MAIN-CLAUSE-AUX-FLAG #adverbial-aux-or-main-clause-aux,
                      FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #full-aux-or-main-clause-aux-or-neg-aux,
                      OBJ-SUFFIX-FLAG #obj-suffix,
                      INTRANS-SUFFIX-OR-TRANS-AGR-SUFFIX-FLAG #intrans-suffix-or-trans-agr-suffix,
                      TRANS-AGR-SUFFIX-FLAG #trans-agr-suffix,
                      ADVERBIAL-AUX-OR-FULL-AUX-OR-NEG-AUX-OR-OBL-TRANS-VERB-FLAG #adverbial-aux-or-full-aux-or-neg-aux-or-obl-trans-verb,
                      MAIN-CLAUSE-AUX-FLAG #main-clause-aux,
                      ADVERBIAL-AUX-OR-FULL-AUX-OR-MAIN-CLAUSE-AUX-OR-NEG-AUX-FLAG #adverbial-aux-or-full-aux-or-main-clause-aux-or-neg-aux,
                      TRANS-SUFFIX-FLAG #trans-suffix,
                      OBL-TRANS-FLAG #obl-trans ] ] ].

nom-prefix-lex-rule := nominalizer-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM nom ].

nom-subj-suffix-lex-rule := infl-lex-rule & verb-subj-lex-rule &
  [ INFLECTED [ NOM-PREFIX-FLAG - ] ].

1st-pl-nom-subj-suffix-lex-rule := nom-subj-suffix-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                PER 1st ] ].

2nd-pl-nom-subj-suffix-lex-rule := nom-subj-suffix-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ NUM pl,
                                                                PER 2nd ] ].

3rd-nom-subj-suffix-lex-rule := nom-subj-suffix-lex-rule & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

;;; Verbs

clause-embed-lex := main-verb-lex & clausal-second-arg-trans-lex-item & subj-suffix-rule-dtr
 [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps > ,
   ARG-ST < [ LOCAL.CAT.HEAD +np ],
             #comps &
            [ LOCAL [ CAT [ HEAD comp & 
                               [ FORM subord ],
                            VAL [ SUBJ < >,
                                  COMPS < > ] ],
                      CONT.HOOK.INDEX.SF prop-or-ques ] ] >,
   INFLECTED [ SUBJ-SUFFIX-FLAG  - ] ].
   
prop-embed-lex := clause-embed-lex &
 [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF prop ].
 
ques-embed-lex := clause-embed-lex &
 [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF ques ].

nominal-comp-lex := main-verb-lex & trans-first-arg-raising-lex-item-1 & subj-suffix-rule-dtr &
  [ SYNSEM.LOCAL [ CAT [ HEAD.PRD +,
                       VAL [ SPR < >,
                             SPEC < >,
                             COMPS < #comps &
                                     [ LOCAL.CAT.HEAD [ FORM nom,
                                                        PRD + ] ] .
                                     #vcomps >,
                             SUBJ < #subj > ] ],
                  CONT.HOOK.XARG #xarg ],
    ARG-ST < #subj &
             [ LOCAL [ CAT [ HEAD noun &
                                  [ CASE #case ],
                             VAL [ SUBJ < >,
                                   SPR < >,
                                   SPEC < >,
                                   COMPS < > ] ],
                       CONT.HOOK.INDEX #xarg ] ],
            #comps &
            [ LIGHT +,
              LOCAL [ CONT.HOOK.XARG #xarg,
	              CAT [ HEAD verb,
                          VAL [ COMPS #vcomps,
                                SUBJ < [ LOCAL.CAT.HEAD.CASE #case ] > ] ] ] ] >,
    INFLECT [ SUBJ-SUFFIX-FLAG - ] ].



;;; Modifiers

adjective-lex := basic-adjective-lex & intersective-mod-lex & norm-ltop-lex-item &
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ MOD < [ LOCAL.CAT [ HEAD noun,
                                                      VAL.SPR cons ] ] > ],
                           VAL [ SUBJ < >,
                                 COMPS < >,
                                 SPR < >,
                                 SPEC < > ],
                           POSTHEAD - ],
                     CONT.HOOK.XARG #ind ],
             LKEYS.KEYREL.ARG1 #ind ] ].


adverb-lex := basic-adverb-lex & intersective-mod-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD < [ LOCAL.CAT [ HEAD verb & 
                                                       [ FORM finite ] ] ] >,
                           VAL [ SPR < >,
                                 SUBJ < >,
                                 COMPS < >,
                                 SPEC < > ],
                           POSTHEAD + ] ] ] ].

complementizer-lex-item := raise-sem-lex-item & basic-one-arg &
 [ SYNSEM.LOCAL [ CAT [ HEAD comp,
                        VAL [ COMPS < #comps >,
                              SUBJ < > ] ],
                  CONT.HOOK.INDEX.SF prop-or-ques ],
   ARG-ST < #comps &
            [ LOCAL [ CAT [ HEAD +vj & 
                               [ FORM subord ],
                            VAL [ SUBJ < >,
                                  COMPS < > ] ],
                      CONT.HOOK.INDEX.SF prop-or-ques ] ] > ].


;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

n-bar-predicate-phrase := unary-phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD verb &
                             [ MOD < > ],
                       VAL [ COMPS < >,
                             SPEC < >,
                             SPR < >,
                             SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg1,
                                              CAT [ HEAD noun,
                                                    VAL.SPR < > ] ] ] > ],
                       INIT + ],
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #index,
                    XARG #arg1 ],
             RELS <! arg12-ev-relation &
                   [ PRED "_be_v_id_rel",
                     LBL #ltop,
                     ARG0 #index,
                     ARG1 #arg1,
                     ARG2 #arg2 ],
                     quant-relation &
                   [ PRED "exist_q_rel",
                     ARG0 #arg2,
                     RSTR #harg ] !>,
             HCONS <! qeq &
                    [ HARG #harg, 
                      LARG #larg ] !> ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  VAL.SPR cons ],
                            CONT.HOOK [ INDEX #arg2,
                                        LTOP #larg ] ] ] > ].

adj-predicate-phrase := unary-phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb &
                             [ MOD < > ],
                       VAL [ COMPS < >,
                             SPEC < >,
                             SPR < >,
                             SUBJ < [ LOCAL [ CONT.HOOK.INDEX #arg2,
                                              CAT [ HEAD noun,
                                                    VAL.SPR < > ] ] ] > ] ],
                     CONT [ HOOK.INDEX #ind ] ],
    C-CONT [ HOOK.XARG #arg1,
            RELS <! !> ],
    ARGS < [ SYNSEM [ LOCAL [ CAT [ HEAD adj &
                                       [ MOD < [ LOCAL.CONT.HOOK.INDEX #arg2 ] > ] ],
                              CONT.HOOK.XARG #arg1 ],
	              LKEYS.KEYREL.ARG0 #ind ] ] > ].


;             RELS <! arg12-ev-relation &
;                    [ PRED "_be_v_id_rel",
;                      LBL #ltop,
;                      ARG0 #index,
;                      ARG1 #arg1,
;                      ARG2 #arg2 ] !> ],
    
comp-aux-phrase := basic-head-1st-comp-phrase & head-final &
  [ SYNSEM.LOCAL.CAT [ HEAD verb &
                          [ AUX + ],
                       INIT + ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.INIT - ,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb,
                                    INIT + ] ].

interrog-aux-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ SYNSEM.LOCAL[ CAT [ HEAD verb &
                             [ AUX + ],
                        INIT - ],
                  CONT.HOOK.INDEX.SF ques ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.INIT - ,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD verb,
                                    INIT - ] ].



;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;


;basic-head-subj-phrase :+ [ SYNSEM.LOCAL.CAT.COMPSAT #cs,
;			    HEAD-DTR.SYNSEM.LOCAL.CAT.COMPSAT #cs ].

;basic-head-opt-subj-phrase :+ [ SYNSEM.LOCAL.CAT.COMPSAT #cs,
;			        HEAD-DTR.SYNSEM.LOCAL.CAT [ COMPSAT #cs,
;			                                    VC + ] ].

;basic-head-opt-comp-phrase :+ [ SYNSEM.LOCAL.CAT.COMPSAT #cs,
;			        HEAD-DTR.SYNSEM.LOCAL.CAT.COMPSAT #cs ].

                                    
;;; Auxiliaries

;interrog-aux-lex := arg-comp-aux-no-pred &
;  [ SYNSEM.LOCAL [ CAT [ HEAD [ QUES + ],
;                         VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORM finite,
;                         INIT - ],
;  		   CONT.HOOK.INDEX.SF ques ],
;    INFLECTED [ ] ].                                    
                                    
;comp-aux-phrase := basic-marker-comp-phrase & marker-final-phrase & basic-head-1st-comp-phrase & head-final &
;  [ MARKER-DTR.SYNSEM.LOCAL.CAT [ HEAD verb &
;                                       [ AUX +,
;				         PRD -,
;				         QUES -,
;                                         FORM #vform ],
;     				  COMPSAT - ],
;    NON-MARKER-DTR.SYNSEM.LOCAL.CAT [ HEAD verb,
;                                      VC #vc ],
;    SYNSEM.LOCAL.CAT [ VC #vc,
;		       COMPSAT +,
;                       HEAD verb &
;                            [ FORM #vform,
;                              AUX +,
;			      PRD - ,
;			      QUES - ] ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].

;interrog-comp-aux-phrase := basic-marker-comp-phrase & marker-final-phrase & ba;sic-head-1st-comp-phrase & head-final &
;  [ MARKER-DTR.SYNSEM.LOCAL.CAT [ HEAD #head,
;                                 COMPSAT - ],
;    NON-MARKER-DTR.SYNSEM.LOCAL.CAT [ HEAD verb,
;                                      VC #vc ],
;    SYNSEM.LOCAL.CAT [ VC #vc,
;                       HEAD #head & verb & 
;			    [ QUES +,
;			      AUX +,
;			      PRD - ],
;   		       COMPSAT + ],
;    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb &
;				       [ PRD + ] ].


;interrog-comp-aux-non3rd-phrase := interrog-comp-aux-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.COMPSAT - ].

;interrog-comp-aux-3rd-phrase := interrog-comp-aux-phrase &
;  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.COMPSAT + ].
